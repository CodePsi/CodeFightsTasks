"texts,""Year"",""President"",""FirstName"""
"Програмування:

Програмування — процес проектування, написання, тестування, зневадження і підтримки комп'ютерних програм. Програмування поєднує в собі елементи інженерії (існує навіть відповідна спеціальна галузь інженерії — програмна інженерія, англ. software engineering), фундаментальних наук (перш за все математики) і мистецтва[1].

У вужчому значенні програмування розглядається як кодування — реалізація у вигляді програми одного чи кількох взаємопов'язаних алгоритмів (у сучасних умовах це здійснюється з застосуванням мов програмування). У ширшому сенсі процес програмування охоплює і створення, тобто розробку, алгоритмів, і аналіз потреб майбутніх користувачів програмного забезпечення.

У широкому значенні програмування використовується у значенні створення програми дій або алгоритмів та навчання людей або пристроїв діяти за алгоритмами."
"Критерії якості
Яким би не був підхід до створення програмного забезпечення, кінцева програма має задовольняти деяким вимогам. Найчастіше зустрічаються[джерело не вказане 2702 дні]:

Ефективність/Продуктивність: кількість ресурсів системи, що споживає програма (час процесора, розмір пам'яті, зовнішня пам'ять, ширина каналу мережі, і навіть взаємодії з користувачем). Чим менше ресурсів споживається, тим краще;
Надійність: ймовірність того, що результат роботи програми правильний. Це залежить від коректності алгоритмів та правильності кодування;
Стійкість: як програма розв'язує проблеми в нестандартних ситуаціях, як наприклад неправильні дані, недоступність необхідних ресурсів як наприклад пам'ять, локальна мережа, та неправильні дії користувача;
Зручність: ергономічність програми. Легкість, з якою особа може використовувати програму для своїх цілей;
Переносимість: діапазон апаратного забезпечення та операційних систем на яких можна компілювати чи інтерпретувати код програми, виконуючи її. Це залежить від відмінностей в програмних ресурсах наданих різними платформами, включаючи ресурси, наявність компіляторів та бібліотек для мови програмування;
Масштабованість: Простота подальшого супроводження програми, тобто внесення в неї додаткових вдосконалень, що збільшують функціональність чи виправляють помилки. Цей критерій не має прямого відношення до користувача, але впливає на час, протягом якого програма буде використовуватись.
Рівні програмування
Успішне програмування передбачає виконання необхідних дій на таких рівнях[джерело?]:

Економічний (бізнес-логіка): Формування вимог до програмного продукту з урахуванням привабливості для користувачів, прибутковості для розробника і наявних можливостей розробника;
Структурний (архітектура): Створення переліку і взаємозв'язків потрібних модулів, графічних і звукових елементів, алгоритмів, баз даних, файлів, вибір мови програмування;
Детальний/Фізичний (кодування): Реалізація окремих функцій з використанням конструкцій і операторів мови програмування, друкування тексту програми на клавіатурі. Власне перші мови програмування з'явилися задовго до появи перших комп'ютерів. Ще в 19-му столітті існували «програмовані» ткацькі верстати та піаніно-програвачі, спосіб програмування нагадує так звані предметно-орієнтовані мови програмування. На початку 20-го століття починають використовуватись перфокарти, та механічна обробка даних. В 1930 ?1940 рр. виникає лямбда-числення та машина Тюринга, які застосовували математичну абстракцію для опису алгоритмів. Лямбда-числення згодом здійснило вплив на проектування мов програмування.[5]

В 1940 роках створюються перші електричні, двійкові комп'ютери. Вважається, що першу мову програмування високого рівня — Планкалькюль (нім. Plankalk?l) розробив німець Конрад Цузе в період 1943–1945 років, але в той час вона не була реалізована і не одержала уваги. Реалізацією мови зайнялися і здійснили лише в 1998—2000 роках[6].

Наприкінці 40-их — початку 50-их застосовувалися інтерпретовані системи кодування, коли певні команди мови програмування кодувалися числами, які вже інтерпретувалися машинним кодом. Ці системи називалися «автоматичним програмуванням» і були простішими для програмування, ніж машинні коди, але могли мати значно меншу (до 50 разів) швидкодію, через що часто надавали перевагу машинним кодам. До таких систем належали — Short Code для BINAC (1949) і UNIVAC I (1952), Speedcoding[en] для IBM 701, розроблена Джоном Бекусом у 1954.

Першою широковживаною компільованою мовою став розроблений групою Джона Бекуса Фортран, анонсований 1954 року й випущений 1957 року для IBM 704. Основним призначенням Фортрану були швидкі наукові обчислення, оголошувалося, що швидкодія згенерованого компілятором коду майже не відрізнятиметься від написаного вручну машинного коду. Уже у квітні 1958 близько половини програм для IBM 704 були написані на Фортрані. Випущений у 1958 році Фортран II дозволяв незалежну компіляцію підпрограм, що дозволило створювати більші програми, оскільки низька надійність IBM 704 не дозволяла скомпілювати без збоїв велику програму (понад 300—400 рядків) одразу. Розроблений у 1960–1962 роках Фортран IV був однією з найпоширеніших мов того часу і лишався стандартною версією Фортрану до появи 1978 року Фортрану 77.

1958 року в MIT розробили LISP — першу функційну мову, яка понад чверть століття домінувала у програмуванні задач штучного інтелекту.

Наприкінці 1950-их почали розроблятися різні мови програмування. 1958 року декілька значних груп комп'ютерних користувачів у США, включаючи SHARE — групу науковців-користувачів IBM і USE (UNIVAC Scientific Exchange, група науковців-користувачів UNIVAC) запропонували ACM заснувати робочу групу зі створення універсальної мови програмування. Також ще 1955 року німецьке Товариство прикладної математики і механіки (GAMM) заснувало комітет зі створення універсальної мови програмування. В кінці травня 1958 року було проведено зустріч у Цюриху між ACM і GAMM, на матеріалах якої у грудні опубліковано «ALGOL 58 Report». На його основі було створено 3 значні реалізації — MAD (1961), NELIAC (1963), JOVIAL (1963). З них лише JOVIAL отримав поширення, ставши на чверть століття офіційною мовою програмування у Військово-морських силах США. SHARE і IBM почали створення власної реалізації ALGOL, але припинили, врахувавши витрати на створення і просування Фортрану.

Впродовж 1959 року ALGOL 58 широко обговорювався, була запропонована нотація для опису синтаксису мов програмування — форма Бекуса-Наура. 1960 року проведено чергову зустріч і опубліковано ALGOL 60 Report. ALGOL вплинув на багато мов програмування і став стандартною мовою для публікації алгоритмів, але через ряд причин не одержав широкого поширення — він був заскладним, і не було реалізацій, які підтримували його повністю, відсутність стандартного введення-виведення привела до появи різних несумісних реалізацій, деякі неоднозначності опису мови так і не були розв'язані. Також широкого вжитку уже набув Фортран, і IBM не підтримала ALGOL.

1959 року було проведено зустріч у Пентагоні для створення мови CBL (Common Business Language), засновано комітет з його створення, і 1960 року опубліковано початкову специфікацію COBOL 60, який невдовзі став першою мовою прийнятою у Міністерстві оборони США. 1968 року COBOL було стандартизовано ANSI.

1964 року було створено спрощену мову BASIC (Beginners All-purpose Symbolic Instruction Code) для навчання програмуванню студентів, які переважно спеціалізувалися у вільних мистецтвах, а не технічних науках.

Тоді як науковці переважно використовували Фортран, а бізнес — COBOL, 1963 року в IBM вирішили створити універсальні платформу IBM/360 і мову програмування. У стислі терміни до 1965 року було розроблено мову PL/I, яка поєднувала можливості Фортран, ALGOL і COBOL, і виявилась заскладною, хоча і була у широкому вжитку у 1970-их у наукових і бізнес задачах, також її підмножини (PL/C, PL/CS) використовувалися для навчання програмуванню.

На початку 1960-их було створено перші мови із динамічною типізацією — APL і SNOBOL.

SIMULA 67 була першою об'єктно-орієнтованою мовою програмування.

1965 року Ніклаус Вірт і Тоні Гоар запропонували комітету з розвитку мови ALGOL свою версію, яку згодом назвали ALGOL-W і застосовували для навчання в деяких університетах. Пропозиція була відхилена через незначну кількість змін на користь значно складнішого ALGOL 68. У ALGOL 68 з'явилися визначення структур даних і динамічні масиви. ALGOL 68 став першою мовою із формальною специфікацією, яка однак була складною для розуміння.

1971 року Вірт опублікував опис мови Pascal, яка у 70-их стала загальновживаною для навчання студентів.

1972 року Деніс Річі розробив у Bell Labs мову C. Тоді ж у Марселі створено інтерпретатор мови Пролог — першої і найвідомішої мови логічного програмування. Алан Кей у Xerox PARC розробив першу широко вживану об'єктно-орієнтовану мову — Smalltalk.

1973 року Робін Мілнер в Единбурзькому університеті створив ML.

1975 року в Массачусетському технологічному інституті описано спрощений діалект мови Лісп — Scheme.

1976 року випущено мову для статистичного програмування S, на базі якої 1993 року створено R.

1977 року випущено Bourne shell і awk.

1975 року Міністерство оборони США утворило міжнародну групу для створення нової мови програмування для власних потреб, конкурс 1979 року виграла мова Ада.

1981 року випущено dBASE II.

1984 року з метою об'єднання різних діалектів Ліспу створено Common Lisp. Випущено MATLAB

1985 року Б'ярн Страуструп опублікував реалізацію мови C++.

1986 року опубліковано мову Objective-C і створено Erlang. Тоді ж Borland і Apple незалежно створили об'єктно-орієнтоване розширення мови Pascal — Object Pascal.

1987 року створено Perl.

1990 року опубліковано Standard ML і Haskell.

1991 року створено Visual Basic і опубліковано Python.

1992 року випущено Oracle 7 з підтримкою PL/SQL

1993 року створено Lua.

1995 року Sun Microsystems випустила Java, Netscape — JavaScript, тоді ж створено PHP і Ruby.

1996 року створено OCaml.

2001 року створено C#.

2002 року створено F#.

2003 року створено Scala.

2009 року створено Go.

2010 року створено Rust.

2014 року на конференції розробників WWDC 2014 було представлено мову Swift."
"Рівень абстракції 
Мови програмування високого рівня оперують сутностями ближчими людині, такими як об'єкти, змінні, функції. Мови програмування нижчого рівня оперують сутностями ближчими машині: байти, адреси, інструкції. Текст програми на мові високого рівня зазвичай набагато коротший ніж текст такої самої програми на мові низького рівня, проте програма має більший розмір.
Область застосування
Універсальні та спеціалізовані. Спеціалізовані мови теж бувають Тьюрінг-повні, та все ж їх область застосування обмежена, як наприклад у мови shell.
Підтримувані парадигми програмування 
Об'єктно-орієнтовані, логічні, функційні, структурні…
Імперативні мови базуються на ідеї змінної, значення якої змінюється присвоєнням. Вони називаються імперативними (лат. imperative — наказовий), оскільки складаються із послідовностей команд, які звичайно містять присвоєння змінних <назва_змінної> = <вираз>, де вираз може посилатися на значення змінних присвоєних попередніми командами.

Способи реалізації мов
Мови програмування можуть бути реалізовані як компільовані та інтерпретовані.

Програма на компільованій мові за допомогою компілятора (особливої ??програми) (компілюється) в машинний код (набір інструкцій) для даного типу процесора, що записується у об'єктний модуль. З одного або кількох об'єктних файлів компонувальник формує виконуваний файл, який може бути запущений на виконання як окрема програма. Іншими словами, компілятор переводить вихідний текст програми з мови програмування високого рівня в двійкові коди інструкцій процесора.

Якщо програма написана на скриптовій мові, то інтерпретатор безпосередньо виконує (інтерпретує) вихідний текст без попереднього перекладу. При цьому програма залишається мовою оригіналу і не може бути запущена без інтерпретатора. Процесор комп'ютера, в зв'язку з цим, можна назвати інтерпретатором для машинного коду.

Поділ на компільовані і інтерпретовані мови є умовним. Так, для будь-якої традиційно компілючої мови, як, наприклад, Паскаль, можна написати інтерпретатор. Крім того, більшість сучасних «чистих» інтерпретаторів не виконують конструкції мови безпосередньо, а компілюють їх в деяке високорівневе проміжне представлення (наприклад, з розіменуванням змінних і розкриттям макросів).

Для будь-якої інтерпритуючої мови можна створити компілятор — наприклад, мова Лісп, початково інтерпретована, може компілюватися без обмежень. Створюваний під час виконання програми код може так само динамічно компілюватися під час виконання.

Як правило, скомпільовані програми виконуються швидше і не вимагають для виконання додаткових програм, так як вже переведені на машинну мову. Разом з тим, при кожній зміні тексту програми потрібно її перекомпіляція, що уповільнює процес розробки. Крім того, скомпільована програма може виконуватися тільки на тому ж типі комп'ютерів і, як правило, під тією ж операційною системою, на яку був розрахований компілятор. Щоб створити виконуваний файл для машини іншого типу, потрібна нова компіляція.

Інтерпретовані мови володіють деякими специфічними додатковими можливостями (див. вище), крім того, програми на них можна запускати відразу ж після зміни, що полегшує розробку. Програма на скриптовій мові може бути найчастіше запущена на різних типах машин та операційних систем без додаткових зусиль.

Однак інтерпретовані програми виконуються помітно повільніше, ніж компільовані, крім того, вони не можуть виконуватися без програми-інтерпретатора.

Деякі мови, наприклад, Java та C #, перебувають між компільованими і інтерпретованими. А саме, програма компілюється не в машинну мову, а в машинно-незалежний код низького рівня, байт-код. Далі байт-код виконується віртуальною машиною. Для виконання байт-коду зазвичай використовується інтерпретація, хоча окремі його частини для прискорення роботи програми можуть бути трансльовані в машинний код безпосередньо під час виконання програми за технологією компіляції «на льоту» (Just-in-time compilation, JIT). Для Java байт-код виповнюється віртуальною машиною Java (Java Virtual Machine, JVM), для C # — Common Language Runtime.

Подібний підхід у деякому сенсі дозволяє використовувати плюси як інтерпретаторів, так і компіляторів. Слід згадати, що є мови, які мають і інтерпретатор, і компілятор (Форт (Forth)). Тіло процедури, як і програми, у свою чергу може містити описи процедур і функцій. Таким чином, процедури і функції можуть бути вкладені один в одного як завгодно глибоко, при цьому тіло програми — саме верхнє в ланцюжку.

Причому вміст секцій опису змінних, типів, констант, зовнішнього тіла (процедури, функції, програми), розташованих перед описом процедури/функції, доступні усередині неї. Також, в більшості діалектів з процедури можна звертатися до параметрів зовнішньої процедури.

Услід за заголовком процедур/функцій замість тіла може поміщатися ключове слово forward, це робиться в тому випадку, якщо опис процедури/функції розташовується в програмі після її виклику, і пов'язано з підтримуваною в Паскалі можливістю компіляції програми за один прохід.

Процедури відрізняються від функцій тим, що функції повертають якесь значення, а процедури — ні.

Об'єктно-орієнтоване програмування
Об'єктно-орієнтоване програмування (ООП) — це технологія створення складного програмного забезпечення, яке засноване на представленні програми у вигляді сукупності об'єктів, кожен з яких є екземпляром певного класу, а класи утворюють ієрархію із спадкоємством властивостей.

Основна перевага ООП — це значне спрощення процесів створення та модифікації програмних систем. Набагато легше маніпулювати 100 об'єктами, кожен з яких сам відповідає за свою поведінку і обробку даних пов'язаних з ним, ніж тисячами функцій розкиданих по різних модулях.

Основні недоліки в ООП — це деяке зниження швидкодії через складнішу організацію програмної системи, а також, як правило, помітне збільшення об'єму бінарного коду (особливо при використанні стандартних бібліотек класів в невеликих програмах) через те, що більшість сучасних компіляторів і компонувальників не здатні виявити і видалити весь код, що доводиться на невживані класи, віртуальні методи і інші елементи ООП.

Семантика мов програмування
Докладніше: Семантика мов програмування
Існує кілька підходів до визначення семантики мов програмування.

Найбільш широко поширені наступні три різновиди семантик: операційна, дериваційна (аксіоматична) і денотаційна (математична)[джерело?].

При описі семантики в рамках операційного підходу зазвичай виконання конструкцій мови програмування інтерпретується за допомогою деякої уявної (абстрактної) ЕОМ.
Дериваційна семантика описує наслідки виконання конструкцій мови за допомогою мови логіки і завдання перед- і пост-умов.
Денотаційна семантика оперує поняттями, типовими для математики — множини, відповідності, а також судження, твердження та ін.Перші комп'ютери доводилось програмувати двійковими машинними кодами. Проте програмувати таким чином — доволі трудомістке і важке завдання[10]. Для спрощення цього завдання почали з'являтися мови програмування низького рівня, які дозволяли задавати машинні команди в зрозумілішому для людини вигляді. Для перетворення їх у двійковий код були створені спеціальні програми — асемблери.


Приклад машинного коду і представлення його на асемблері[11]
Прикладом мови низького рівня є мова асемблера. Мови низького рівня орієнтовані на конкретний тип процесора і враховують його особливості, тому для перенесення програми на асемблері на іншу апаратну платформу її потрібно майже цілком переписати. Певні відмінності є і в синтаксисі програм під різні компілятори. Щоправда, центральні процесори для комп'ютерів фірм AMD та Intel практично сумісні і відрізняються лише деякими специфічними командами. А ось спеціалізовані процесори для інших пристроїв, наприклад, відеокарт, телефонів містять суттєві відмінності.

Переваги
За допомогою мов низького рівня створюють ефективні і компактні програми, оскільки розробник отримує доступ до всіх можливостей процесора.

Недоліки
Програміст, що працює з мовами низького рівня, має бути високої кваліфікації, добре розуміти будову мікропроцесорної системи, для якої створює програму.
Результуюча програма не може бути перенесена на комп'ютер або пристрій з іншим типом процесора; часто труднощі виникають і при перенесенні програми для іншої операційної системи
Значний час розробки великих і складних програм.
Мови низького рівня, як правило, використовують для написання невеликих системних програм, драйверів пристроїв, модулів стиків з нестандартним обладнанням, програмування спеціалізованих мікропроцесорів, коли найважливішими вимогами є компактність, швидкодія і можливість прямого доступу до апаратних ресурсів.

Мови програмування високого рівня
Докладніше: Мова програмування високого рівня
Транслятори[12] поділяються на:

компілятори — перетворюють текст програми в машинний код, який можна зберегти і після цього використовувати уже без компілятора (прикладом є виконувальні файли з розширенням *.exe).
інтерпретатори — перетворюють частину програми в машинний код, виконують і після цього переходять до наступної частини. При цьому щоразу при виконанні програми використовується інтерпретатор.
Можна сказати є зрозумілішими людині, ніж комп'ютеру. Особливості конкретних комп'ютерних архітектур в них не враховуються, тому створені програми легко переносяться з комп'ютера на комп'ютер. Здебільшого достатньо просто перекомпілювати програму під певну комп'ютерну архітектурну та операційну систему. Розробляти програми на таких мовах значно простіше і помилок допускається менше. Значно скорочується час розробки програми, що особливо важливо при роботі над великими програмними проектами.

Наразі у середовищі розробників вважається, що мови програмування, які мають прямий доступ до пам'яті та регістрів або мають асемблерні вставки, потрібно вважати мовами програмування з низьким рівнем абстракції. Тому більшість мов, які вважалися мовами високого рівня до 2000-го року зараз вже такими не вважаються.

Адресна мова програмування
Фортран
Кобол
Алгол
Pascal
PascalABC
Java
C
C++
Objective C
Smalltalk
C#
Delphi
Недоліком мов високого рівня є більший розмір програм порівняно з програмами на мові низького рівня. Сам текст програм на мові високого рівня менший, проте, якщо взяти у байтах, то код початково писаний на асемблері буде компактніший. Тому в основному мови високого рівня використовуються для розробок програмного забезпечення комп'ютерів, і пристроїв, які мають великий обсяг пам'яті. А різні підвиди асемблеру застосовуються для програмування інших пристроїв, де критичним є розмір програми.

Покоління мов програмування
Докладніше: Покоління мов програмування
Інколи в літературі та в інтернеті згадують про п'ять поколінь мов програмування[13][14][15][16], щоправда даний поділ є спірним і суперечним. В професійній літературі по програмуванню доволі рідко згадують про покоління мов програмування, а більше зосереджуються на функціональній класифікації мов програмування. Крім того саме віднесення певних мов до різних поколінь різниться у різних авторів.

Поділ на покоління мов програмування почав поширюватись з появою високорівневих мов програмування і до того не застосовувався. Високорівневі мови програмування почали вважатися третім поколінням, асемблерні мови — другим, а машинний код — першим поколінням. Сучасні спроби класифікація мов на четверте і п'яте покоління проводяться різними авторами по різному по різних ознаках і різниця між мовами третього, четвертого та п'ятого покоління часто доволі нечітка. Крім того багато компаній розробники мов програмування та середовищ програмування для них використовують маркетинговий хід проголошуючи певну мову (мову та інтегроване середовище розробки для неї) п'ятим поколінням.

"


